% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ops-image.R
\name{op_image_affine_transform}
\alias{op_image_affine_transform}
\title{Applies the given transform(s) to the image(s).}
\usage{
op_image_affine_transform(
  image,
  transform,
  interpolation = "bilinear",
  fill_mode = "constant",
  fill_value = 0L,
  data_format = "channels_last"
)
}
\arguments{
\item{image}{Input image or batch of images. Must be 3D or 4D.}

\item{transform}{Projective transform matrix/matrices. A vector of length 8 or
tensor of size N x 8. If one row of transform is
\verb{[a0, a1, a2, b0, b1, b2, c0, c1]}, then it maps the output point
\verb{(x, y)} to a transformed input point
\verb{(x', y') = ((a0 x + a1 y + a2) / k, (b0 x + b1 y + b2) / k)},
where \verb{k = c0 x + c1 y + 1}. The transform is inverted compared to
the transform mapping input points to output points. Note that
gradients are not backpropagated into transformation parameters.
Note that \code{c0} and \code{c1} are only effective when using TensorFlow
backend and will be considered as \code{0} when using other backends.}

\item{interpolation}{Interpolation method. Available methods are \code{"nearest"},
and \code{"bilinear"}. Defaults to \code{"bilinear"}.}

\item{fill_mode}{Points outside the boundaries of the input are filled
according to the given mode. Available methods are \code{"constant"},
\code{"nearest"}, \code{"wrap"} and \code{"reflect"}. Defaults to \code{"constant"}.
\itemize{
\item \code{"reflect"}: \verb{(d c b a | a b c d | d c b a)}
The input is extended by reflecting about the edge of the last
pixel.
\item \code{"constant"}: \verb{(k k k k | a b c d | k k k k)}
The input is extended by filling all values beyond
the edge with the same constant value k specified by
\code{fill_value}.
\item \code{"wrap"}: \verb{(a b c d | a b c d | a b c d)}
The input is extended by wrapping around to the opposite edge.
\item \code{"nearest"}: \verb{(a a a a | a b c d | d d d d)}
The input is extended by the nearest pixel.
}}

\item{fill_value}{Value used for points outside the boundaries of the input if
\code{fill_mode = "constant"}. Defaults to \code{0}.}

\item{data_format}{string, either \code{"channels_last"} or \code{"channels_first"}.
The ordering of the dimensions in the inputs. \code{"channels_last"}
corresponds to inputs with shape \verb{(batch, height, width, channels)}
while \code{"channels_first"} corresponds to inputs with shape
\verb{(batch, channels, height, weight)}. It defaults to the
\code{image_data_format} value found in your Keras config file at
\verb{~/.keras/keras.json}. If you never set it, then it will be
\code{"channels_last"}.}
}
\value{
Applied affine transform image or batch of images.
}
\description{
Applies the given transform(s) to the image(s).
}
\section{Examples}{
\if{html}{\out{<div class="sourceCode r">}}\preformatted{x <- random_uniform(c(2, 64, 80, 3)) # batch of 2 RGB images
transform <- op_array(rbind(c(1.5, 0, -20, 0, 1.5, -16, 0, 0),  # zoom
                           c(1, 0, -20, 0, 1, -16, 0, 0)))  # translation))
y <- op_image_affine_transform(x, transform)
shape(y)
}\if{html}{\out{</div>}}

\if{html}{\out{<div class="sourceCode">}}\preformatted{## shape(2, 64, 80, 3)

}\if{html}{\out{</div>}}

\if{html}{\out{<div class="sourceCode r">}}\preformatted{# (2, 64, 80, 3)
}\if{html}{\out{</div>}}

\if{html}{\out{<div class="sourceCode r">}}\preformatted{x <- random_uniform(c(64, 80, 3)) # single RGB image
transform <- op_array(c(1.0, 0.5, -20, 0.5, 1.0, -16, 0, 0))  # shear
y <- op_image_affine_transform(x, transform)
shape(y)
}\if{html}{\out{</div>}}

\if{html}{\out{<div class="sourceCode">}}\preformatted{## shape(64, 80, 3)

}\if{html}{\out{</div>}}

\if{html}{\out{<div class="sourceCode r">}}\preformatted{# (64, 80, 3)
}\if{html}{\out{</div>}}

\if{html}{\out{<div class="sourceCode r">}}\preformatted{x <- random_uniform(c(2, 3, 64, 80)) # batch of 2 RGB images
transform <- op_array(rbind(
  c(1.5, 0,-20, 0, 1.5,-16, 0, 0),  # zoom
  c(1, 0,-20, 0, 1,-16, 0, 0)  # translation
))
y <- op_image_affine_transform(x, transform, data_format = "channels_first")
shape(y)
}\if{html}{\out{</div>}}

\if{html}{\out{<div class="sourceCode">}}\preformatted{## shape(2, 3, 64, 80)

}\if{html}{\out{</div>}}

\if{html}{\out{<div class="sourceCode r">}}\preformatted{# (2, 3, 64, 80)
}\if{html}{\out{</div>}}
}

\seealso{
\itemize{
\item \url{https://keras.io/api/ops/image#affinetransform-function}
}

Other image ops: \cr
\code{\link{op_image_crop}()} \cr
\code{\link{op_image_extract_patches}()} \cr
\code{\link{op_image_map_coordinates}()} \cr
\code{\link{op_image_pad}()} \cr
\code{\link{op_image_resize}()} \cr
\code{\link{op_image_rgb_to_grayscale}()} \cr

Other image utils: \cr
\code{\link{image_array_save}()} \cr
\code{\link{image_from_array}()} \cr
\code{\link{image_load}()} \cr
\code{\link{image_smart_resize}()} \cr
\code{\link{image_to_array}()} \cr
\code{\link{op_image_crop}()} \cr
\code{\link{op_image_extract_patches}()} \cr
\code{\link{op_image_map_coordinates}()} \cr
\code{\link{op_image_pad}()} \cr
\code{\link{op_image_resize}()} \cr
\code{\link{op_image_rgb_to_grayscale}()} \cr

Other ops: \cr
\code{\link{op_abs}()} \cr
\code{\link{op_add}()} \cr
\code{\link{op_all}()} \cr
\code{\link{op_any}()} \cr
\code{\link{op_append}()} \cr
\code{\link{op_arange}()} \cr
\code{\link{op_arccos}()} \cr
\code{\link{op_arccosh}()} \cr
\code{\link{op_arcsin}()} \cr
\code{\link{op_arcsinh}()} \cr
\code{\link{op_arctan}()} \cr
\code{\link{op_arctan2}()} \cr
\code{\link{op_arctanh}()} \cr
\code{\link{op_argmax}()} \cr
\code{\link{op_argmin}()} \cr
\code{\link{op_argsort}()} \cr
\code{\link{op_array}()} \cr
\code{\link{op_average}()} \cr
\code{\link{op_average_pool}()} \cr
\code{\link{op_batch_normalization}()} \cr
\code{\link{op_binary_crossentropy}()} \cr
\code{\link{op_bincount}()} \cr
\code{\link{op_broadcast_to}()} \cr
\code{\link{op_cast}()} \cr
\code{\link{op_categorical_crossentropy}()} \cr
\code{\link{op_ceil}()} \cr
\code{\link{op_cholesky}()} \cr
\code{\link{op_clip}()} \cr
\code{\link{op_concatenate}()} \cr
\code{\link{op_cond}()} \cr
\code{\link{op_conj}()} \cr
\code{\link{op_conv}()} \cr
\code{\link{op_conv_transpose}()} \cr
\code{\link{op_convert_to_numpy}()} \cr
\code{\link{op_convert_to_tensor}()} \cr
\code{\link{op_copy}()} \cr
\code{\link{op_correlate}()} \cr
\code{\link{op_cos}()} \cr
\code{\link{op_cosh}()} \cr
\code{\link{op_count_nonzero}()} \cr
\code{\link{op_cross}()} \cr
\code{\link{op_ctc_decode}()} \cr
\code{\link{op_ctc_loss}()} \cr
\code{\link{op_cumprod}()} \cr
\code{\link{op_cumsum}()} \cr
\code{\link{op_custom_gradient}()} \cr
\code{\link{op_depthwise_conv}()} \cr
\code{\link{op_det}()} \cr
\code{\link{op_diag}()} \cr
\code{\link{op_diagonal}()} \cr
\code{\link{op_diff}()} \cr
\code{\link{op_digitize}()} \cr
\code{\link{op_divide}()} \cr
\code{\link{op_divide_no_nan}()} \cr
\code{\link{op_dot}()} \cr
\code{\link{op_eig}()} \cr
\code{\link{op_eigh}()} \cr
\code{\link{op_einsum}()} \cr
\code{\link{op_elu}()} \cr
\code{\link{op_empty}()} \cr
\code{\link{op_equal}()} \cr
\code{\link{op_erf}()} \cr
\code{\link{op_erfinv}()} \cr
\code{\link{op_exp}()} \cr
\code{\link{op_expand_dims}()} \cr
\code{\link{op_expm1}()} \cr
\code{\link{op_extract_sequences}()} \cr
\code{\link{op_eye}()} \cr
\code{\link{op_fft}()} \cr
\code{\link{op_fft2}()} \cr
\code{\link{op_flip}()} \cr
\code{\link{op_floor}()} \cr
\code{\link{op_floor_divide}()} \cr
\code{\link{op_fori_loop}()} \cr
\code{\link{op_full}()} \cr
\code{\link{op_full_like}()} \cr
\code{\link{op_gelu}()} \cr
\code{\link{op_get_item}()} \cr
\code{\link{op_greater}()} \cr
\code{\link{op_greater_equal}()} \cr
\code{\link{op_hard_sigmoid}()} \cr
\code{\link{op_hard_silu}()} \cr
\code{\link{op_hstack}()} \cr
\code{\link{op_identity}()} \cr
\code{\link{op_imag}()} \cr
\code{\link{op_image_crop}()} \cr
\code{\link{op_image_extract_patches}()} \cr
\code{\link{op_image_map_coordinates}()} \cr
\code{\link{op_image_pad}()} \cr
\code{\link{op_image_resize}()} \cr
\code{\link{op_image_rgb_to_grayscale}()} \cr
\code{\link{op_in_top_k}()} \cr
\code{\link{op_inv}()} \cr
\code{\link{op_irfft}()} \cr
\code{\link{op_is_tensor}()} \cr
\code{\link{op_isclose}()} \cr
\code{\link{op_isfinite}()} \cr
\code{\link{op_isinf}()} \cr
\code{\link{op_isnan}()} \cr
\code{\link{op_istft}()} \cr
\code{\link{op_leaky_relu}()} \cr
\code{\link{op_less}()} \cr
\code{\link{op_less_equal}()} \cr
\code{\link{op_linspace}()} \cr
\code{\link{op_log}()} \cr
\code{\link{op_log10}()} \cr
\code{\link{op_log1p}()} \cr
\code{\link{op_log2}()} \cr
\code{\link{op_log_sigmoid}()} \cr
\code{\link{op_log_softmax}()} \cr
\code{\link{op_logaddexp}()} \cr
\code{\link{op_logical_and}()} \cr
\code{\link{op_logical_not}()} \cr
\code{\link{op_logical_or}()} \cr
\code{\link{op_logical_xor}()} \cr
\code{\link{op_logspace}()} \cr
\code{\link{op_logsumexp}()} \cr
\code{\link{op_lu_factor}()} \cr
\code{\link{op_matmul}()} \cr
\code{\link{op_max}()} \cr
\code{\link{op_max_pool}()} \cr
\code{\link{op_maximum}()} \cr
\code{\link{op_mean}()} \cr
\code{\link{op_median}()} \cr
\code{\link{op_meshgrid}()} \cr
\code{\link{op_min}()} \cr
\code{\link{op_minimum}()} \cr
\code{\link{op_mod}()} \cr
\code{\link{op_moments}()} \cr
\code{\link{op_moveaxis}()} \cr
\code{\link{op_multi_hot}()} \cr
\code{\link{op_multiply}()} \cr
\code{\link{op_nan_to_num}()} \cr
\code{\link{op_ndim}()} \cr
\code{\link{op_negative}()} \cr
\code{\link{op_nonzero}()} \cr
\code{\link{op_norm}()} \cr
\code{\link{op_normalize}()} \cr
\code{\link{op_not_equal}()} \cr
\code{\link{op_one_hot}()} \cr
\code{\link{op_ones}()} \cr
\code{\link{op_ones_like}()} \cr
\code{\link{op_outer}()} \cr
\code{\link{op_pad}()} \cr
\code{\link{op_power}()} \cr
\code{\link{op_prod}()} \cr
\code{\link{op_qr}()} \cr
\code{\link{op_quantile}()} \cr
\code{\link{op_ravel}()} \cr
\code{\link{op_real}()} \cr
\code{\link{op_reciprocal}()} \cr
\code{\link{op_relu}()} \cr
\code{\link{op_relu6}()} \cr
\code{\link{op_repeat}()} \cr
\code{\link{op_reshape}()} \cr
\code{\link{op_rfft}()} \cr
\code{\link{op_roll}()} \cr
\code{\link{op_round}()} \cr
\code{\link{op_rsqrt}()} \cr
\code{\link{op_scatter}()} \cr
\code{\link{op_scatter_update}()} \cr
\code{\link{op_segment_max}()} \cr
\code{\link{op_segment_sum}()} \cr
\code{\link{op_select}()} \cr
\code{\link{op_selu}()} \cr
\code{\link{op_separable_conv}()} \cr
\code{\link{op_shape}()} \cr
\code{\link{op_sigmoid}()} \cr
\code{\link{op_sign}()} \cr
\code{\link{op_silu}()} \cr
\code{\link{op_sin}()} \cr
\code{\link{op_sinh}()} \cr
\code{\link{op_size}()} \cr
\code{\link{op_slice}()} \cr
\code{\link{op_slice_update}()} \cr
\code{\link{op_softmax}()} \cr
\code{\link{op_softplus}()} \cr
\code{\link{op_softsign}()} \cr
\code{\link{op_solve}()} \cr
\code{\link{op_solve_triangular}()} \cr
\code{\link{op_sort}()} \cr
\code{\link{op_sparse_categorical_crossentropy}()} \cr
\code{\link{op_split}()} \cr
\code{\link{op_sqrt}()} \cr
\code{\link{op_square}()} \cr
\code{\link{op_squeeze}()} \cr
\code{\link{op_stack}()} \cr
\code{\link{op_std}()} \cr
\code{\link{op_stft}()} \cr
\code{\link{op_stop_gradient}()} \cr
\code{\link{op_subtract}()} \cr
\code{\link{op_sum}()} \cr
\code{\link{op_svd}()} \cr
\code{\link{op_swapaxes}()} \cr
\code{\link{op_take}()} \cr
\code{\link{op_take_along_axis}()} \cr
\code{\link{op_tan}()} \cr
\code{\link{op_tanh}()} \cr
\code{\link{op_tensordot}()} \cr
\code{\link{op_tile}()} \cr
\code{\link{op_top_k}()} \cr
\code{\link{op_trace}()} \cr
\code{\link{op_transpose}()} \cr
\code{\link{op_tri}()} \cr
\code{\link{op_tril}()} \cr
\code{\link{op_triu}()} \cr
\code{\link{op_unstack}()} \cr
\code{\link{op_var}()} \cr
\code{\link{op_vdot}()} \cr
\code{\link{op_vectorize}()} \cr
\code{\link{op_vectorized_map}()} \cr
\code{\link{op_vstack}()} \cr
\code{\link{op_where}()} \cr
\code{\link{op_while_loop}()} \cr
\code{\link{op_zeros}()} \cr
\code{\link{op_zeros_like}()} \cr
}
\concept{image ops}
\concept{image utils}
\concept{ops}
