% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ops.R
\name{op_associative_scan}
\alias{op_associative_scan}
\title{Performs a scan with an associative binary operation, in parallel.}
\usage{
op_associative_scan(f, elems, reverse = FALSE, axis = 1L)
}
\arguments{
\item{f}{A callable implementing an associative binary operation with
signature \code{r = f(a, b)}. Function \code{f} must be associative, i.e.,
it must satisfy the equation
\code{f(a, f(b, c)) == f(f(a, b), c)}.
The inputs and result are (possibly nested tree structures
of) array(s) matching \code{elems}. Each array has a dimension in place
of the \code{axis} dimension. \code{f} should be applied elementwise over
the \code{axis} dimension.
The result \code{r} has the same shape (and structure) as the
two inputs \code{a} and \code{b}.}

\item{elems}{A (possibly nested tree structure of) array(s), each with
an \code{axis} dimension of size \code{num_elems}.}

\item{reverse}{A boolean stating if the scan should be reversed with respect
to the \code{axis} dimension.}

\item{axis}{an integer identifying the axis over which the scan should occur.}
}
\value{
A (possibly nested tree structure of) array(s) of the same shape
and structure as \code{elems}, in which the \code{k}'th element of \code{axis} is
the result of recursively applying \code{f} to combine the first \code{k}
elements of \code{elems} along \code{axis}. For example, given
\code{elems = list(a, b, c, ...)}, the result would be
\code{list(a, f(a, b), f(f(a, b), c), ...)}.
}
\description{
This operation his similar to \code{\link[=op_scan]{op_scan()}}, with the key difference that
\code{op_associative_scan()} is a parallel implementation with
potentially significant performance benefits, especially when jit compiled.
The catch is that it can only be used when \code{f} is a binary associative
operation (i.e. it must verify \code{f(a, f(b, c)) == f(f(a, b), c)}).

For an introduction to associative scans, refer to this paper:
Blelloch, Guy E. 1990.
\href{https://www.cs.cmu.edu/~guyb/papers/Ble93.pdf}{Prefix Sums and Their Applications}.
}
\section{Examples}{
\if{html}{\out{<div class="sourceCode r">}}\preformatted{sum_fn <- function(x, y) x + y
xs <- op_arange(5L)
op_associative_scan(sum_fn, xs)
}\if{html}{\out{</div>}}

\if{html}{\out{<div class="sourceCode">}}\preformatted{## tf.Tensor([ 0  1  3  6 10], shape=(5), dtype=int32)

}\if{html}{\out{</div>}}

\if{html}{\out{<div class="sourceCode r">}}\preformatted{sum_fn <- function(x, y) \{
  str(list(x = x, y = y))
  map2(x, y, \\(.x, .y) .x + .y)
\}

xs <- list(op_array(1:2),
           op_array(1:2),
           op_array(1:2))
ys <- op_associative_scan(sum_fn, xs, axis = 1)
}\if{html}{\out{</div>}}

\if{html}{\out{<div class="sourceCode">}}\preformatted{## List of 2
##  $ x:List of 3
##   ..$ :<tf.Tensor: shape=(1), dtype=int32, numpy=array([1], dtype=int32)>
##   ..$ :<tf.Tensor: shape=(1), dtype=int32, numpy=array([1], dtype=int32)>
##   ..$ :<tf.Tensor: shape=(1), dtype=int32, numpy=array([1], dtype=int32)>
##  $ y:List of 3
##   ..$ :<tf.Tensor: shape=(1), dtype=int32, numpy=array([2], dtype=int32)>
##   ..$ :<tf.Tensor: shape=(1), dtype=int32, numpy=array([2], dtype=int32)>
##   ..$ :<tf.Tensor: shape=(1), dtype=int32, numpy=array([2], dtype=int32)>

}\if{html}{\out{</div>}}

\if{html}{\out{<div class="sourceCode r">}}\preformatted{ys
}\if{html}{\out{</div>}}

\if{html}{\out{<div class="sourceCode">}}\preformatted{## [[1]]
## tf.Tensor([1 3], shape=(2), dtype=int32)
##
## [[2]]
## tf.Tensor([1 3], shape=(2), dtype=int32)
##
## [[3]]
## tf.Tensor([1 3], shape=(2), dtype=int32)

}\if{html}{\out{</div>}}
}

